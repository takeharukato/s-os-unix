TODO list

楯岡さんTODO

・DOS 部分のライセンスのクリア
・リアルタイム入力の改良
・BYTE,char,unsigned char 関係のコードの整理
・もっと綺麗なキーカスタマイズ
・拡張セットの機能の導入
・仮想画面管理部と実画面制御部の分離

(*) DOS 部分のライセンスのクリアについては, PDS宣言があるので問題は無し
加藤TODO
* DOSへの依存の排除
* 垂直同期の時間間隔の計測
* クロックティックに応じてCPUの命令を処理

[Console Command Processor]
* CCPを独立化
* マウントコマンドにイメージファイル種別を指定可能にする
* マウントコマンドにファイルシステム種別を指定可能にする
* マウントコマンドにリードオンリーマウントを指定可能にする

[エミュレーション環境]

[tape]
* テープデバイスの共通化
  - テープデバイスドライバ部作成
  - ホストファイルシステムドライバ(QD)を作成
  - Sをホストドライブにすべきか検討
* trap.cのテープ関連処理をテープデバイス処理部に移動
  sos_trdd, sos_rdi, sos_wri, sos_twrd, sos_tdir, の実処理をtape.cに
  移動し, 'T', 'S', 'Q'を区別可能にする

[QD]
* ホストの.objファイル参照処理
  ディレクトトリエントリ中に書かれているファイル長は, ヘッダを含まない長さであるので,
  実際の読み書き時はヘッダサイズ分を加算して実施
  ヘッダの書込み:
  * creat時にDTADR, DTEXEを0に設定
  * write終了時にfibの内容に従ってヘッダを書き込んだ後にデータを書き込み
  ヘッダの読み込み:
  * open時に, RDONLYの場合に実施

[DiskImages]
* mztへの対応
* D88フォーマット対応

[fs]
fs_swd_search_dent_by_nameは, ディレクトリvnodeから名前を探し, v-node IDを返すよう
修正
- fopsのlookupの途中まで実装,
- 残りは,
* fs_swd_search_dent_by_nameにdir_vnodeを渡すようにする
* fops_creatにdir_vnodeを渡すようにする(pathからdir_vnodeを割り出すのは, vfs_creatの役目)
* fops_openにdir_vnodeを渡すようにする(pathからdir_vnodeを割り出すのは, vfs_creatの役目)
* fops_renameのfs_swd_search_dent_by_name呼び出し時にdir->vnodeを渡すようにする


* dir関連IF
  fs_swd_search_dent_by_dirno
  fs_swd_search_dent_by_name
  fs_swd_search_free_dent
  fs_swd_write_dent
  は, dirのvnodeを引数に取り, ルートでなければ, そのディレクトリのクラスタのディレクトリ
  エントリを辿り, ルートの場合は, ioctxからdirpsを取得するように修正する。
  このためには, chの代わりにv-nodeを渡すようにfops全般に修正する
  v-nodeを渡せば, vn->vn_fib.fib_devltrでデバイスを取得することができるので
  chの代用になる.

  1. fs_swd_get_block_number, fs_swd_release_blocks, fs_swd_get_used_size_in_block
     にioctxを引き渡し, storage_set_fatpos, storage_get_fatpos,
     struct _storage_disk_posのdp_fatposを除去[済]

  2. path名からvnodeを取得, path名からディレクトリv-nodeを取得する関数を作成
  3. 2.をデバッグ

  4. fopsのIFを見直す
     a. struct _sword_file_descriptorのfd_fibを
        vnodeへのポインタに置換え,
     b. struct _sword_dirのdir_posからdir_ioctxを削除し, struct _sword_file_descriptor
        に置換え
  5. 今のfs-swordの実装をコピーしておき, vnodeへのポインタを渡す形式で書き直す
     FS2.txt参照

  fs_swd_search_dent_by_dirno  757 src/fs-sword.c   	rc = fs_swd_search_dent_by_dirno(dir_fib->fib_devltr, dir->dir_ioctx,
  =>  dir->dir_fibが取得できるはずなので, chの代わりにdirを使用

fs_swd_search_dent_by_name  251 src/fs-sword.c   	rc = fs_swd_search_dent_by_name(ch, ioctx, &swd_name[0], &vnid);
fs_swd_search_dent_by_name  388 src/fs-sword.c   	rc = fs_swd_search_dent_by_name(ch, ioctx, &swd_name[0], &vnid);
=>createとopenなので, path_to_dir_vnode, path_to_dirを実装して, dirを得る

fs_swd_search_dent_by_name  917 src/fs-sword.c   	rc = fs_swd_search_dent_by_name(dir_fib->fib_devltr, dir->dir_ioctx,
fs_swd_search_dent_by_name  936 src/fs-sword.c   	rc = fs_swd_search_dent_by_name(dir_fib->fib_devltr, dir->dir_ioctx,
fs_swd_search_dent_by_name  996 src/fs-sword.c   	rc = fs_swd_search_dent_by_name(dir_fib->fib_devltr, dir->dir_ioctx,
fs_swd_search_dent_by_name 1060 src/fs-sword.c   	rc = fs_swd_search_dent_by_name(dir_fib->fib_devltr, dir->dir_ioctx,
  =>dir->dir_fib.fib_vnid
ch, ioctzの代わりにdirを使用

fs_swd_search_free_dent  162 include/fs-sword.h int fs_swd_search_free_dent(sos_devltr _ch, const struct _fs_ioctx *_ioctx,
fs_swd_search_free_dent  264 src/fs-sword.c   	rc = fs_swd_search_free_dent(ch, ioctx, &vnid);

fs_swd_write_dent   94 src/fs-sword.c   	rc = fs_swd_write_dent(fib->fib_devltr, ioctx, fib); /* write back */
fs_swd_write_dent  292 src/fs-sword.c   	rc = fs_swd_write_dent(ch, ioctx, &fib);
fs_swd_write_dent  534 src/fs-sword.c   		rc = fs_swd_write_dent(fib->fib_devltr, fdp->fd_ioctx, fib);
fs_swd_write_dent  948 src/fs-sword.c   	rc = fs_swd_write_dent(dir_fib->fib_devltr, dir->dir_ioctx, &old_fib);
fs_swd_write_dent 1012 src/fs-sword.c   	rc = fs_swd_write_dent(dir_fib->fib_devltr, dir->dir_ioctx, &fib);
fs_swd_write_dent 1074 src/fs-sword.c   	rc = fs_swd_write_dent(dir_fib->fib_devltr, dir->dir_ioctx, &fib);


* storage管理とは別にマウントテーブルを管理する方針に方針変更。
  * root_fibを保持できるようにする必要があるため。
  * _fs_fopsにfib比較処理を追加して, SWORDの場合, fibのfib_clsで比較する。
  * SWORDの場合は, vnodeのvnidを以下のように指定する
    * 上位32bitsを対象ファイルが入っているディレクトリのクラスタ番号
      (rootディレクトリの場合は, 0)
    * 下位32bitsを対象ファイルの先頭クラスタ番号
    これによりvnidがマウントポイント内で一意になるようにする。
  root i-nodeのfib->fib_clsを0に設定することで, root i-nodeだった場合,
    ioctxのdirpsに設定されているレコードの内容を元にlooupを実行することで, FAT12/Hu-Basic
    のようなディレクトリエントリを一貫してクラスタ番号で管理するファイルシステムと
    共存可能にする。
  mount_pointの定義は以下
  struct _mount_point{
  	 vfs_dev_id            m_dev;  /**< Device index */
	 struct _fs_fs_manager  m_fs;  /**< File system */

};
  マウントポイントIDは, 配列のインデクスで代用する。

  #define MOUNT_POINT_NR	STORAGE_NR

  typedef int			vfs_dev_id;

struct _mount_point mount_tbl[MOUNT_POINT_NR];

* fatpos/dirpsはioctxを参照するようにする
* dent操作にディレクトリのクラスタ番号を指定できるようにすること
* fd/dirのfibメンバは, v-nodeにするべき
* ファイルシステムマウント処理作成
* ファイルシステムマウント時にioctxにrootディレクトリエントリを設定する
* ファイルシステム共通部(fs-vfs)作成
* fatpos, dirpsをスーパブロック情報から取得するように修正
* WA_DIRPS, WA_FATPOSの更新を見張って, スーパーブロックの
  fatpos, dirpsのスーパブロック情報を更新
  (やりすぎか, システムコールで更新するべき?)
* マウントテーブルの導入によりcheck_file_existsが不要になるので削除

[fs済]
* デバイスレターをポジション情報からディレクトリストリームに移動[済]
  * dp_devltr使用箇所をfib_devltrに置換え, dirにfibを追加
  * 基本的な考え方は, S-OSのディレクトリはファイルとして扱われていない
    (ディレクトリに対するi-nodeはない)が, fibをinodeの変わりとして扱い,
    dirストリームにfibを入れて内部的には, fibを通してデバイスを参照する方針で実装する。
    これにより, デバイスレターの取得は, fibを通して行うように統一する。
* ファイルサイズを変えない場合にブロックの獲得や解放が起こらないことの確認[済]
* クラスタ内部でのファイルサイズ変更時の動作確認[済]
* fs_swd_read_block/fs_swd_write_blockに書込みバイト数を返却する機能を実装[済]
* set/resetの為にchmodオペレーションが必要[済]
* creatを要作成[済]
* sword fsのfatpos, dirps=>fatrec, dirps_rec変換処理を共通化する[済]
* fatrec dirpsを引数に持つ関数を内部で現在のfatrec, dirpsを取得させるように修正[済]
* read/write, creatなどの本体部分を共通化しヘッダを書き込む, 読み飛ばすことが出来るように
  する(正確に書くと, rawポジションへの読み書き処理, ヘッダを含むポジションへの
  読み書き処理を作成する)[済]
* read/write/seekでヘッダを読み飛ばす処理が必要[済]
  ファイルサイズを足してもFATの使用サイズとは合わないと言うだけで, ファイルの読み書き,
  解放は,  FATに従って行うので読み書き, ブロックの獲得・解放処理時のポジションに
  ヘッダサイズを足せば良い(read/write/tuncateのポジションを補正)
* 型の妥当性を確認, VFSに必要な型を導入[済]
  * ファイルサイズ
  * ファイル最大値
* swordのエラーコードを引数で返すようにし, 内部エラーと区別がつくようにする[済]
* ファイルポジションがファイルの終端を指している場合, EoFとして返り値0を返すようにする[済]
  =>Readでのブロックの獲得失敗時にファイル終端と見なすようにした。
* ブロックの使用クラスタ長を超えて読み込まないようにread処理を修正[済]
  最終クラスタのリード時にremainsと使用クラスタ長のいずれか小さいサイズのみを
  コピーレングスにして, remainsより使用クラスタ長の方が小さい場合
  remainsから使用クラスタ長をrdcntから減算する
  このためには, get_block_swordでクラスタ内の使用レコード長を取得できるように
  しないといけない。
* クラスタの途中まで書き込む場合に, 過不足無くクラスタ内レコードを割り当てる。
  書き込み時のブロック獲得ポジションにバッファコピー処理の終端のクラスタ先頭からの
  オフセットを指定するように修正.
* DIRPS/FATアクセスをマクロ化してread/write誤りを防ぐようにする[済]
* ブロックへの読み書きIFを再考すること[済]
* release_block_swordで独自にリリース対象ブロックを算出している
  処理をget_cluster_number_swordに置き換えること[済]
* 1ブロック余計に割り当てられる問題を修正すること[済]
* ブロック割当て関数でクラスタサイズのみを伸長する場合の処理を追加[済]
  truncateのバッファクリア処理との重複を排除[済]

[storage]
* マウント処理でファイルシステムを指定できるようにする
* マウント処理でファイルシステムストレージ単位での書込み禁止を指定できるようにする
* fib_read/fib_writeは, シーケンシャルデバイスからの読み書きを使用すれば実現できるが
  テープの内部ポジションを知っている必要があるのでstorageオペレーションに入っている

[セキュリティ]
* strtokをstrtok_rに置換え

[移植性]
* memmove, memcpy, memset, memrchrのOS依存の排除
* stdint.hのOS依存の排除

DOS依存システムコール
1. HOT
2. WOPEN
3. WRD
4. RDD
5. DRDSB
6. DWTSB
7. DIR
8. ROPEN
9. SET
10. RESET
11. NAME
12. KILL
13. RDVSW
14. SDVSW
15. ERROR
16. P#fnam
17. devchk
18. tpchk

[1] RDD
    - RDD  234f
    - DEVCHK 2851
    - RDD1 236a
    - TRDD 290c
    - DSKCHK 2591
    - FATRED 26ff
    - DLOAD 25e3

    1. #DSKを読み込んでDEVCHKを呼ぶ
    2. DEVCHKがエラーならキャリーをセットして復帰
    3. DEVCHKした結果がテープデバイスならTRDDを呼び出し後復帰
    4. DIRNOとRETPOIを0に設定
    5. オープンされていなければ, File Not Openを返して, キャリーをセットして復帰
    6. オープンされていればデバイスをクローズ
    7. DSKCHKを呼び出して標準ディスクでなければ, Reserved Featureを返して復帰
    8. FATREDを呼び出してFATをFATPOSに読み込む
    9. DLOADを呼び出してFATの内容に従ってファイルの内容をDTADRに読み込む

* ディレクトリエントリレコードの先頭(dirps)とFATレコードの先頭をdirとfibの双方で
  持っている問題を解消[済]
  1. FATレコードは, ファイルの削除とディレクトリエントリの削除の双方で使うので, posに移動
     し, storage-ifによって得る[済]
  2. storage-ifにdirps, fatposを参照・更新するIFを追加する[済]
  3. DIR構造体のディレクトリエントリレコードの先頭(dirps)エントリを削除[済]
  4. fibディレクトリエントリは, 使用用途がないので削除[済]
* src/trap.cの以下をsos.hに移動[済]
  TRAP_FNAME_BUFSIZ, TRAP_FNAME_EXT_BUFSIZ, TRAP_FNAME_PRNT_BUFSIZ
* strrchrのOS依存の排除[済]
* strncasecmpのOS依存の排除[済]
* zedaでQ:のファイルを読めない原因の調査[済]