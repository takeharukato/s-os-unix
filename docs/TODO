TODO list

楯岡さんTODO

・DOS 部分のライセンスのクリア
・リアルタイム入力の改良
・BYTE,char,unsigned char 関係のコードの整理
・もっと綺麗なキーカスタマイズ
・拡張セットの機能の導入
・仮想画面管理部と実画面制御部の分離

(*) DOS 部分のライセンスのクリアについては, PDS宣言があるので問題は無し
加藤TODO
* zedaでQ:のファイルを読めない原因の調査[済]
* DOSへの依存の排除
* trap.cのテープ関連処理をテープデバイス処理部に移動
  sos_trdd, sos_rdi, sos_wri, sos_twrd, sos_tdir, の実処理をtape.cに
  移動し, 'T', 'S', 'Q'を区別可能にする
* テープデバイスの共通化
* mztへの対応
* 垂直同期の時間間隔の計測
* クロックティックに応じてCPUの命令を処理
* D88フォーマット対応
* strrchrのOS依存の排除[済]
* strtokをstrtok_rに置換え
* strncasecmpのOS依存の排除[対応済み]
* memmove, memcpy, memset, memrchrのOS依存の排除

src/trap.cをsos.hに移動
#define TRAP_FNAME_BUFSIZ         ( SOS_FNAME_LEN + 1 )     /* name + ext + '\0' */
#define TRAP_FNAME_EXT_BUFSIZ     ( SOS_FNAME_EXTLEN + 1 )  /* ext + '\0' */
#define TRAP_FNAME_PRNT_BUFSIZ    ( TRAP_FNAME_BUFSIZ + 1 ) /* name + '.' + ext + '\0' */
check_file_existsが不要になるので削除
fib_read/fib_writeは, シーケンシャルデバイスからの読み書きを使用すれば実現できるが
テープの内部ポジションを知っている必要があるのでstorageオペレーションに入っている

DOS依存システムコール
1. HOT
2. WOPEN
3. WRD
4. RDD
5. DRDSB
6. DWTSB
7. DIR
8. ROPEN
9. SET
10. RESET
11. NAME
12. KILL
13. RDVSW
14. SDVSW
15. ERROR
16. P#fnam
17. devchk
18. tpchk

[1] RDD
    - RDD  234f
    - DEVCHK 2851
    - RDD1 236a
    - TRDD 290c
    - DSKCHK 2591
    - FATRED 26ff
    - DLOAD 25e3

    1. #DSKを読み込んでDEVCHKを呼ぶ
    2. DEVCHKがエラーならキャリーをセットして復帰
    3. DEVCHKした結果がテープデバイスならTRDDを呼び出し後復帰
    4. DIRNOとRETPOIを0に設定
    5. オープンされていなければ, File Not Openを返して, キャリーをセットして復帰
    6. オープンされていればデバイスをクローズ
    7. DSKCHKを呼び出して標準ディスクでなければ, Reserved Featureを返して復帰
    8. FATREDを呼び出してFATをFATPOSに読み込む
    9. DLOADを呼び出してFATの内容に従ってファイルの内容をDTADRに読み込む

FATRED
    内部関数だがAレジスタにエラー番号を設定して復帰する
        1. DEとHLを保存
	2. FATPS(FATのレコード)とFATBF(書込先WAアドレス)をDE,HLに設定,
	   レコード読み取り数1をAに設定してDSKREDを呼んでセクタを読み込む
	   (Aにエラー番号が入る)
        3. DEとHLを復元
	4. 復帰

DLOAD 25e3
    IBFADのオフセット0x1E(30)から先頭クラスタ番号を取り出して
    クラスタチェインを追跡してレコードの内容をメモリに転送する
    クラスタチェインを追跡する際に00を検出したら Bad allocation table(7)を
    返して復帰
    DSKREDがエラーを返したらそのエラーを返して復帰