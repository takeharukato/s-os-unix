TODO list

楯岡さんTODO

・DOS 部分のライセンスのクリア
・リアルタイム入力の改良
・BYTE,char,unsigned char 関係のコードの整理
・もっと綺麗なキーカスタマイズ
・拡張セットの機能の導入
・仮想画面管理部と実画面制御部の分離

(*) DOS 部分のライセンスのクリアについては, PDS宣言があるので問題は無し
加藤TODO
* DOSへの依存の排除
* 垂直同期の時間間隔の計測
* クロックティックに応じてCPUの命令を処理

[Console Command Processor]
* CCPを独立化
* マウントコマンドにイメージファイル種別を指定可能にする
* マウントコマンドにファイルシステム種別を指定可能にする
* マウントコマンドにリードオンリーマウントを指定可能にする

[エミュレーション環境]

[tape]
* テープデバイスの共通化
  - テープデバイスドライバ部作成
  - ホストファイルシステムドライバ(QD)を作成
  - Sをホストドライブにすべきか検討
* trap.cのテープ関連処理をテープデバイス処理部に移動
  sos_trdd, sos_rdi, sos_wri, sos_twrd, sos_tdir, の実処理をtape.cに
  移動し, 'T', 'S', 'Q'を区別可能にする

[QD]
* ホストの.objファイル参照処理
  ディレクトトリエントリ中に書かれているファイル長は, ヘッダを含まない長さであるので,
  実際の読み書き時はヘッダサイズ分を加算して実施
  ヘッダの書込み:
  * creat時にDTADR, DTEXEを0に設定
  * write終了時にfibの内容に従ってヘッダを書き込んだ後にデータを書き込み
  ヘッダの読み込み:
  * open時に, RDONLYの場合に実施

[DiskImages]
* mztへの対応
* D88フォーマット対応

[fs]
* デバイスレターをポジション情報からディレクトリストリームに移動。
  - ファイル操作: dp_devltr使用箇所をfib_devltrに置換え
  - ディレクトリ操作: dp_devltr使用箇所をdir_devltrに置換え
* ファイルシステムマウント処理作成
* ファイルシステム共通部(fs-vfs)作成
* fatpos, dirpsをスーパブロック情報から取得するように修正
* WA_DIRPS, WA_FATPOSの更新を見張って, スーパーブロックの
  fatpos, dirpsのスーパブロック情報を更新
  (やりすぎか, システムコールで更新するべき?)
* マウントテーブルの導入によりcheck_file_existsが不要になるので削除

[fs済]
* ファイルサイズを変えない場合にブロックの獲得や解放が起こらないことの確認[済]
* クラスタ内部でのファイルサイズ変更時の動作確認[済]
* fs_swd_read_block/fs_swd_write_blockに書込みバイト数を返却する機能を実装[済]
* set/resetの為にchmodオペレーションが必要[済]
* creatを要作成[済]
* sword fsのfatpos, dirps=>fatrec, dirps_rec変換処理を共通化する[済]
* fatrec dirpsを引数に持つ関数を内部で現在のfatrec, dirpsを取得させるように修正[済]
* read/write, creatなどの本体部分を共通化しヘッダを書き込む, 読み飛ばすことが出来るように
  する(正確に書くと, rawポジションへの読み書き処理, ヘッダを含むポジションへの
  読み書き処理を作成する)[済]
* read/write/seekでヘッダを読み飛ばす処理が必要[済]
  ファイルサイズを足してもFATの使用サイズとは合わないと言うだけで, ファイルの読み書き,
  解放は,  FATに従って行うので読み書き, ブロックの獲得・解放処理時のポジションに
  ヘッダサイズを足せば良い(read/write/tuncateのポジションを補正)
* 型の妥当性を確認, VFSに必要な型を導入[済]
  * ファイルサイズ
  * ファイル最大値
* swordのエラーコードを引数で返すようにし, 内部エラーと区別がつくようにする[済]
* ファイルポジションがファイルの終端を指している場合, EoFとして返り値0を返すようにする[済]
  =>Readでのブロックの獲得失敗時にファイル終端と見なすようにした。
* ブロックの使用クラスタ長を超えて読み込まないようにread処理を修正[済]
  最終クラスタのリード時にremainsと使用クラスタ長のいずれか小さいサイズのみを
  コピーレングスにして, remainsより使用クラスタ長の方が小さい場合
  remainsから使用クラスタ長をrdcntから減算する
  このためには, get_block_swordでクラスタ内の使用レコード長を取得できるように
  しないといけない。
* クラスタの途中まで書き込む場合に, 過不足無くクラスタ内レコードを割り当てる。
  書き込み時のブロック獲得ポジションにバッファコピー処理の終端のクラスタ先頭からの
  オフセットを指定するように修正.
* DIRPS/FATアクセスをマクロ化してread/write誤りを防ぐようにする[済]
* ブロックへの読み書きIFを再考すること[済]
* release_block_swordで独自にリリース対象ブロックを算出している
  処理をget_cluster_number_swordに置き換えること[済]
* 1ブロック余計に割り当てられる問題を修正すること[済]
* ブロック割当て関数でクラスタサイズのみを伸長する場合の処理を追加[済]
  truncateのバッファクリア処理との重複を排除[済]

[storage]
* マウント処理でファイルシステムを指定できるようにする
* マウント処理でファイルシステムストレージ単位での書込み禁止を指定できるようにする
* fib_read/fib_writeは, シーケンシャルデバイスからの読み書きを使用すれば実現できるが
  テープの内部ポジションを知っている必要があるのでstorageオペレーションに入っている

[セキュリティ]
* strtokをstrtok_rに置換え

[移植性]
* memmove, memcpy, memset, memrchrのOS依存の排除
* stdint.hのOS依存の排除

DOS依存システムコール
1. HOT
2. WOPEN
3. WRD
4. RDD
5. DRDSB
6. DWTSB
7. DIR
8. ROPEN
9. SET
10. RESET
11. NAME
12. KILL
13. RDVSW
14. SDVSW
15. ERROR
16. P#fnam
17. devchk
18. tpchk

[1] RDD
    - RDD  234f
    - DEVCHK 2851
    - RDD1 236a
    - TRDD 290c
    - DSKCHK 2591
    - FATRED 26ff
    - DLOAD 25e3

    1. #DSKを読み込んでDEVCHKを呼ぶ
    2. DEVCHKがエラーならキャリーをセットして復帰
    3. DEVCHKした結果がテープデバイスならTRDDを呼び出し後復帰
    4. DIRNOとRETPOIを0に設定
    5. オープンされていなければ, File Not Openを返して, キャリーをセットして復帰
    6. オープンされていればデバイスをクローズ
    7. DSKCHKを呼び出して標準ディスクでなければ, Reserved Featureを返して復帰
    8. FATREDを呼び出してFATをFATPOSに読み込む
    9. DLOADを呼び出してFATの内容に従ってファイルの内容をDTADRに読み込む

* ディレクトリエントリレコードの先頭(dirps)とFATレコードの先頭をdirとfibの双方で
  持っている問題を解消[済]
  1. FATレコードは, ファイルの削除とディレクトリエントリの削除の双方で使うので, posに移動
     し, storage-ifによって得る[済]
  2. storage-ifにdirps, fatposを参照・更新するIFを追加する[済]
  3. DIR構造体のディレクトリエントリレコードの先頭(dirps)エントリを削除[済]
  4. fibディレクトリエントリは, 使用用途がないので削除[済]
* src/trap.cの以下をsos.hに移動[済]
  TRAP_FNAME_BUFSIZ, TRAP_FNAME_EXT_BUFSIZ, TRAP_FNAME_PRNT_BUFSIZ
* strrchrのOS依存の排除[済]
* strncasecmpのOS依存の排除[済]
* zedaでQ:のファイルを読めない原因の調査[済]