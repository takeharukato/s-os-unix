TODO list

楯岡さんTODO

・DOS 部分のライセンスのクリア
・リアルタイム入力の改良
・BYTE,char,unsigned char 関係のコードの整理
・もっと綺麗なキーカスタマイズ
・拡張セットの機能の導入
・仮想画面管理部と実画面制御部の分離

(*) DOS 部分のライセンスのクリアについては, PDS宣言があるので問題は無し
加藤TODO
* DOSへの依存の排除
* 垂直同期の時間間隔の計測
* クロックティックに応じてCPUの命令を処理

[Console Command Processor]
* CCPを独立化
* マウントコマンドにイメージファイル種別を指定可能にする
* マウントコマンドにファイルシステム種別を指定可能にする
* マウントコマンドにリードオンリーマウントを指定可能にする

[エミュレーション環境]

[tape]
* テープデバイスの共通化
  - テープデバイスドライバ部作成
  - ホストファイルシステムドライバ(QD)を作成
  - Sをホストドライブにすべきか検討
* trap.cのテープ関連処理をテープデバイス処理部に移動
  sos_trdd, sos_rdi, sos_wri, sos_twrd, sos_tdir, の実処理をtape.cに
  移動し, 'T', 'S', 'Q'を区別可能にする

[QD]
* ホストの.objファイル参照処理
  ディレクトトリエントリ中に書かれているファイル長は, ヘッダを含まない長さであるので,
  実際の読み書き時はヘッダサイズ分を加算して実施
  ヘッダの書込み:
  * creat時にDTADR, DTEXEを0に設定
  * write終了時にfibの内容に従ってヘッダを書き込んだ後にデータを書き込み
  ヘッダの読み込み:
  * open時に, RDONLYの場合に実施
[DiskImages]
* mztへの対応
* D88フォーマット対応

[fs]
* DIRPS/FATアクセスをマクロ化してread/write誤りを防ぐようにする
* ブロックへの読み書きIFを再考すること
  - ブロックサイズ境界の途中のファイルポジションからの書込みを考慮する
    =>1ブロック単位の読み書き処理を導入した方がやはりわかりやすいか?
    =>現状のIFはread/write recと同様連続n個のクラスタに書き込む処理
    になっているはずだが要確認

* release_block_swordで独自にリリース対象ブロックを算出している[済]
  処理をget_cluster_number_swordに置き換えること。
  =>ロジックを書き直した方が速い
* 1ブロック余計に割り当てられる問題を修正すること。
  =>クラスタアライメントの時は割り当てない, NEXT_ALIGNで計算して
  0以上の場合にのみ割り当てるように修正する。
  =>現在のロジックを日本語にして, ロジック修正案を検討する
  調査対象:get_cluster_number_sword
    NEXT_ALIGNで計算して必要ブロック数を計算するように修正,
    クラスタ内rec_size計算時も同様だが, RECORDアラインでポジションを
    算出した場合(NEXTALIGN)に0にならないことを確認
* ブロック割当て関数でクラスタサイズのみを伸長する場合の処理を追加
  truncateのバッファクリア処理との重複を排除

---
#4  0x0000555555556450 in main (argc=2, argv=0x7fffffffe288) at tst-swd-fs4.c:518
(gdb) x /32b &fat[0]
0x7fffffffcea0: 0x01    0x8f    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffcea8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffceb0: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffceb8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00

#4  0x0000555555556590 in main (argc=2, argv=0x7fffffffe288) at tst-swd-fs4.c:528
(gdb) x /32b &fat[0]
0x7fffffffcea0: 0x01    0x8f    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffcea8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffceb0: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffceb8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00

#4  0x0000555555556770 in main (argc=2, argv=0x7fffffffe288) at tst-swd-fs4.c:543
(gdb) p newsiz
$78 = 4096
(gdb) p fib->fib_cls
$79 = 2
(gdb) x /32b &fat[0]
0x7fffffffcea0: 0x01    0x8f    0x80    0x88    0x00    0x00    0x00    0x00
                                ~~~~
                                つながっていない
0x7fffffffcea8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffceb0: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffceb8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) p /x fat[fib->fib_cls]
$81 = 0x80

        /* Truncate 0 */
528:    rc = fs_vfs_truncate(&fd, 0, &res); <= ここまでは正しい
        sos_assert( rc == 0 );
        sos_assert( res == 0 );

        /* Truncate 2 block (extends) */
        rc = fs_vfs_truncate(&fd, SOS_CLUSTER_SIZE, &res); (*)クラスタチェインがつながらない?
        sos_assert( rc == 0 );
        sos_assert( res == 0 );

        /* Truncate 2.5 block without allocating blocks by shirnking  */
        rc = fs_vfs_truncate(&fd, SOS_CLUSTER_SIZE + SOS_CLUSTER_SIZE/2, &res); (*)クラスタチェインがつながらない?
        sos_assert( rc == 0 );
        sos_assert( res == 0 );

        /* Truncate 2 block without releasing blocks by shirnking */
	543:    rc = fs_vfs_truncate(&fd, SOS_CLUSTER_SIZE, &res); <=ここで解放ループが働いていない?
---
* ファイルサイズを変えない場合にブロックの獲得や解放が起こらないことの確認
  (念のため)
* クラスタ内部でのファイルサイズ変更時の動作確認
* ファイルシステムマウント処理作成
* ファイルシステム共通部(fs-vfs)作成
* fatpos, dirpsをスーパブロック情報から取得するように修正
* WA_DIRPS, WA_FATPOSの更新を見張って, スーパーブロックの
  fatpos, dirpsのスーパブロック情報を更新
  (やりすぎか, システムコールで更新するべき?)
* マウントテーブルの導入によりcheck_file_existsが不要になるので削除

[fs済]
* fs_swd_read_block/fs_swd_write_blockに書込みバイト数を返却する機能を実装[済]
* set/resetの為にchmodオペレーションが必要[済]
* creatを要作成[済]
* sword fsのfatpos, dirps=>fatrec, dirps_rec変換処理を共通化する[済]
* fatrec dirpsを引数に持つ関数を内部で現在のfatrec, dirpsを取得させるように修正[済]
* read/write, creatなどの本体部分を共通化しヘッダを書き込む, 読み飛ばすことが出来るように
  する(正確に書くと, rawポジションへの読み書き処理, ヘッダを含むポジションへの
  読み書き処理を作成する)[済]
* read/write/seekでヘッダを読み飛ばす処理が必要[済]
  ファイルサイズを足してもFATの使用サイズとは合わないと言うだけで, ファイルの読み書き,
  解放は,  FATに従って行うので読み書き, ブロックの獲得・解放処理時のポジションに
  ヘッダサイズを足せば良い(read/write/tuncateのポジションを補正)
* 型の妥当性を確認, VFSに必要な型を導入[済]
  * ファイルサイズ
  * ファイル最大値
* swordのエラーコードを引数で返すようにし, 内部エラーと区別がつくようにする[済]
* ファイルポジションがファイルの終端を指している場合, EoFとして返り値0を返すようにする[済]
  =>Readでのブロックの獲得失敗時にファイル終端と見なすようにした。
* ブロックの使用クラスタ長を超えて読み込まないようにread処理を修正[済]
  最終クラスタのリード時にremainsと使用クラスタ長のいずれか小さいサイズのみを
  コピーレングスにして, remainsより使用クラスタ長の方が小さい場合
  remainsから使用クラスタ長をrdcntから減算する
  このためには, get_block_swordでクラスタ内の使用レコード長を取得できるように
  しないといけない。
* クラスタの途中まで書き込む場合に, 過不足無くクラスタ内レコードを割り当てる。
  書き込み時のブロック獲得ポジションにバッファコピー処理の終端のクラスタ先頭からの
  オフセットを指定するように修正.

[storage]
* マウント処理でファイルシステムを指定できるようにする
* マウント処理でファイルシステムストレージ単位での書込み禁止を指定できるようにする
* fib_read/fib_writeは, シーケンシャルデバイスからの読み書きを使用すれば実現できるが
  テープの内部ポジションを知っている必要があるのでstorageオペレーションに入っている

[セキュリティ]
* strtokをstrtok_rに置換え

[移植性]
* memmove, memcpy, memset, memrchrのOS依存の排除
* stdint.hのOS依存の排除

DOS依存システムコール
1. HOT
2. WOPEN
3. WRD
4. RDD
5. DRDSB
6. DWTSB
7. DIR
8. ROPEN
9. SET
10. RESET
11. NAME
12. KILL
13. RDVSW
14. SDVSW
15. ERROR
16. P#fnam
17. devchk
18. tpchk

[1] RDD
    - RDD  234f
    - DEVCHK 2851
    - RDD1 236a
    - TRDD 290c
    - DSKCHK 2591
    - FATRED 26ff
    - DLOAD 25e3

    1. #DSKを読み込んでDEVCHKを呼ぶ
    2. DEVCHKがエラーならキャリーをセットして復帰
    3. DEVCHKした結果がテープデバイスならTRDDを呼び出し後復帰
    4. DIRNOとRETPOIを0に設定
    5. オープンされていなければ, File Not Openを返して, キャリーをセットして復帰
    6. オープンされていればデバイスをクローズ
    7. DSKCHKを呼び出して標準ディスクでなければ, Reserved Featureを返して復帰
    8. FATREDを呼び出してFATをFATPOSに読み込む
    9. DLOADを呼び出してFATの内容に従ってファイルの内容をDTADRに読み込む

* ディレクトリエントリレコードの先頭(dirps)とFATレコードの先頭をdirとfibの双方で
  持っている問題を解消[済]
  1. FATレコードは, ファイルの削除とディレクトリエントリの削除の双方で使うので, posに移動
     し, storage-ifによって得る[済]
  2. storage-ifにdirps, fatposを参照・更新するIFを追加する[済]
  3. DIR構造体のディレクトリエントリレコードの先頭(dirps)エントリを削除[済]
  4. fibディレクトリエントリは, 使用用途がないので削除[済]
* src/trap.cの以下をsos.hに移動[済]
  TRAP_FNAME_BUFSIZ, TRAP_FNAME_EXT_BUFSIZ, TRAP_FNAME_PRNT_BUFSIZ
* strrchrのOS依存の排除[済]
* strncasecmpのOS依存の排除[済]
* zedaでQ:のファイルを読めない原因の調査[済]