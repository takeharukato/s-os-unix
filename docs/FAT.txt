
* 留意事項

  A ファイルに1つもクラスタが割り当たっていなかった場合は,
    呼び出し元で割り当てる。
  B 指定されたファイル位置が1クラスタ未満の場合は, 呼び出さない。
    (Aの条件から)

  C 指定された位置がクラスタの途中だった場合は, ブロック割当て後に
    クラスタ内の指定位置以降のメモリをクリアする処理を呼び出し元で
    実施する
  D ブロックを割り当てる条件は,

    1. 先頭ブロックよりあとのブロック位置を指していて, かつ
    2. そのブロックが割り当てられていない場合

    1. は呼び出し元で判断, 2.はブロック割当て実操作で実施

    つまり

    (1) 読み取り/ブロック解放の場合は, 「(1)で指定された位置の」
        クラスタアラインメントを算出し, クラスタアラインメントサイズで割ることで,
	読み取り対象ブロックを算出する. end of clusterになってもそのインデクスを
	返す。

    (2) (1)のブロック検索でブロックがなかった場合で,
        かつ,
	書込み指示の場合は,  (1)で指定された位置に+1して, クラスタアラインメントの
        「次のアラインメント」を算出して, クラスタアラインメントサイズで割ることで,
	確保するブロック番号を算出する。(1)で返されたインデクス番号のFATの中身を
	新たに割り当てたクラスタの番号に書き換える

	新規に割り当てたクラスタにデータをコピーする際のサイズ
	( (1)で指定された位置+1 をクラスタサイズで割った剰余)
	をレコードサイズで割った数が使用レコード数



    =>つまり, getblockのクラスタ番号算出位置の指定方法にバグがある

[1] クラスタチェイン操作(単方向リスト操作)

(1) 先頭ノードを取り出す
    入力:
    * ヘッドノードへのポインタ(fib)
    * FATテーブルキャッシュへのポインタ
    * FATテーブルの大きさ
    出力:
    * 先頭ノードのブロック番号
    * リスト中にFreeエントリがあった場合は, SOS_ERROR_BADFATを返却
    * ブロックが見つからなかった場合は, SOS_ERROR_NOENTを返却

    1)  ファイルの先頭ブロック番号(fib->fib_cls)次のノードのブロック番号を取得する

    2) 1) で得たブロック番号のクラスタの次のノードのブロック番号を取得する

    3) ファイルの先頭ブロック番号(fib->fib_cls)のFATに2)で得たブロック番号を書き込む

    呼び出し元に1)で得たブロック番号を返却する

(2) ファイル中の指定されたオフセット位置のブロックに対するブロック番号を得る
    入力:
    * ヘッドノードへのポインタ(fib)
    * ファイル内の位置(0から開始)
    * FATテーブルキャッシュへのポインタ
    * FATテーブルの大きさ
    出力:
    * 先頭ノードのブロック番号
    * リスト中に空きエントリがあった場合は, SOS_ERROR_BADFATを返却
    * ブロックが見つからなかった場合は, SOS_ERROR_NOENTを返却


(3) 空きブロックを割り当てる
    (alloc_newblock_sword)
    入力:
    * FATテーブルキャッシュへのポインタ
    出力:
    * 割り当てたノードのブロック番号
    * ブロック割当て失敗時は, SOS_ERROR_NOSPCを返却

    1) FATテーブルのエントリ数を算出
       nr_ents = FATテーブルの大きさ/FATテーブルエントリ長
    2) 0から最終FATエントリまで走査する
       for(i = 0; nr_ents > i; ++i)
          対象ブロックが空きエントリだった場合は, ブロック番号を返却
    3) SOS_ERROR_NOSPCを返却

[2] ブロック操作

(1) 所定のファイル位置のブロック番号を取得する実操作
    (get_cluster_number_sword)

    入力:
    * ファイルの先頭ブロック番号(fib)
    * 検索対象位置(ファイルオフセット)
    * 読み書きの用途種別
    出力:
    * 指定位置のブロック番号
    * 割り当てたブロックの使用サイズ
    * リスト中に空きエントリがあった場合は, SOS_ERROR_BADFATを返却
    * ブロックが見つからなかった場合は, SOS_ERROR_NOENTを返却

    0) FATのキャッシュに現在のFATの内容を読み込む

    1) オフセット位置からファイル中でのオフセットブロック番号を算出
       オフセットブロック番号 = クラスタサイズ境界での開始アドレス/クラスタサイズ
	blk_off = SOS_CALC_ALIGN(pos, SOS_CLUSTER_SIZE)/SOS_CLUSTER_SIZE

    2) 先頭ブロック番号を得る
       cur = fib->fib_cls;

    3) 先頭ブロック番号が空きエントリだった場合は, SOS_ERROR_BADFATを返却

    4) 先頭ブロック番号が終了だった場合は, curとSOS_ERROR_NOENTを返却して復帰

    5) オフセットブロック番号回リンクを辿る
       for(remains = blk_off; remains > 0;
       		   --remains, cur = fat[cur]){ /* 次のクラスタを参照 */

       		   curが空きエントリだった場合は, SOS_ERROR_BADFATを返却

              	   if ( SOS_IS_END_CLS(cur) ) && ( 読み込み用ブロック割当ての場合 ) {

		      curとSOS_ERROR_NOENTを返却して復帰
		   }

		   /*
		    * 新規ブロックを割当て
		    */
		    alloc_newblock_sword()
		    ブロック割当て失敗時は, SOS_ERROR_NOSPCを返却

		    /* SOS_CALC_NEXT_ALIGN(pos, SOS_CLUSTER_SIZE) 使用レコードサイズ
		     * FS_SWD_CALC_RECS_AT_LAST_CLSは以下の式で使用レコード数を返す
		     * SOS_CALC_NEXT_ALIGN(pos, SOS_CLUSTER_SIZE)/SOS_CLUSTER_SIZE;
		     * FS_SWD_CALC_FAT_ENT_AT_LAST_CLSは以下の式でFATの
		     * 最終エントリを返す
		     * SOS_FAT_ENT_EOF_MASK|\
		     * ( ( FS_SWD_CALC_RECS_AT_LAST_CLS(pos) )  - 1 ) & 0xf
		     */

		     /* 途中ブロックを仮定, 仮に全ブロック割当て済みとする */
	            fat[新規ブロック]=FS_SWD_CALC_FAT_ENT_AT_LAST_CLS(SOS_CLUSTER_SIZE-1);
		    if ( remains == 1 ) { /* 最終ブロックの場合 */

		       /* ブロック内でのオフセット位置を算出
		        * (FS_SWD_CAL_USERECS_AT_LAST_CLS)
			*/
		        /* 1バイトでも書き込むはず */
		       sos_assert(pos % SOS_CLUSTER_SIZE > 0);
		       fat[新規ブロック]=FS_SWD_CALC_FAT_ENT_AT_LAST_CLS(pos);
                    }
		    fat[cur] = 新規ブロック;
       }
    7) FATを書き込む
    8) 最終検出ブロック番号(cur)と正常終了を返却して復帰

    a) エラーを返却

(2) 所定のファイル位置以降のブロックを解放する実操作
    (release_block_sword)
    入力:
    * ファイルの先頭ブロック番号(fib)
    * 検索対象位置(ファイルオフセット)
    出力:
    * リスト中に空きエントリがあった場合は, SOS_ERROR_BADFATを返却
    * ブロックが見つからなかった場合は, SOS_ERROR_NOENTを返却


    1) クリア位置(cur)を検索対象位置(ファイルオフセット)に初期化
    2) 読み取りでクリア位置のブロック番号を得る(開始ブロック)
    3) ブロックが見つからなかった場合は, SOS_ERROR_NOENTを返却して復帰
    4) FATのキャッシュに現在のFATの内容を読み込む
    5) 次のブロックがある限り, 以下を実施してブロックを解放
       while( !SOS_IS_END_CLS(fat[cur]) )
    5-1) 次のブロックがフリーエントリーの場合は, SOS_ERROR_BADFATを返却
    5-2) 次のブロックを記憶
         next_blk = fat[cur];
    5-3) ブロックを空きブロックに設定
    	 fat[cur]=SOS_FAT_ENT_FREE;
    5-4) クリア位置にSOS_CLUSTER_SIZEを加算
    5-5) 次のブロックをクリア位置のブロックに設定
         cur = next_blk;

    5) 終了コードを正常終了に設定
       rc = 0
    6) クリアサイズを返却
       クリア位置 - pos
    7) 終了コードを返却

    4) ブロックの途中からの解放の場合(cur % SOS_CLUSTER_SIZEが0でなければ),
    4-1)   cur % SOS_CLUSTER_SIZEから
           SOS_CLUSTER_SIZE - cur % SOS_CLUSTER_SIZE
           サイズをクリア
    4-2)   クリア位置にSOS_CLUSTER_SIZE - クリア位置%SOS_CLUSTER_SIZEを加算
           cur += SOS_CLUSTER_SIZE - cur % SOS_CLUSTER_SIZE;
    4-4) 次のブロックがフリーエントリーの場合は, SOS_ERROR_BADFATを返却
    4-4) 次のブロックを参照
	 cur = fat[cur];
