FCBSCH(0x276B)

FCBを検索する

破壊レジスタ:AF,DE,HL
保存レジスタ:BC

ディレクトリエントリの先頭から1クラスタ分の各ディレクトリエントリ内のファイル名
(HLで参照)を現在の#IFBADに格納されているデータ内のファイル名(DEで参照)と比較して
一致したディレクトリエントリのアドレスをHLに引き渡して復帰する

返り値:
	フラグ値で終了時の状態を判定する
	C=0, Z=0    一致するディレクトリエントリを見つけて正常終了
	            HLに, ディレクトリエントリエントリを格納した#DTBUF
		    の先頭アドレス
		    DEに, ディレクトリエントリのレコード番号
		    を設定して戻る
	C=0, Z=1    一致するディレクトリエントリが見つからなかった
	C=1         ディレクトリ探査中にエラーが発生した
	            Aレジスタにエラーコードが設定される
		    ディスクリード時(DSKRED)が返却するエラーコードが
		    設定される
--- 擬似コード
int
fs_sword_search_dent_low(sos_devltr ch, void **res_dent){
        BYTE attr;
	BYTE *res = NULL;  /* 見つかったエントリ情報を参照する変数 */

	for(rec=#DIRPSで指定されたレコード番号; ; ++rec ) {

		/* 以下の条件でレコードを#DTBUFにディレクトリエントリを読み取る */
		rc = DSKRD(レコード番号=rec,
	      	      読取先アドレス=#DTBUF内に記載されたデータバッファアドレス,
	              読取レコード数=1)
	       if ( rc != 0 ) {

	       	  assert( rc != 3 ); /* File not foundは返さないはず */
		  goto out;
               }

	       /* 1レコード中での探索(*)
	        *  (*) 1レコードに8個のディレクトリエントリが入っているので
		* 8回ループする
		*/
	       for( i = 0; 8 > i; ++i){

		     /* 比較するディレクトリエントリ */
	             res = (BYTE *)(#DTBUF+ (ディレクトリエントリ長(32) * i));
		     attr = *res;  /* ディレクトリエントリ中の属性値を取得 */

		     if ( attr == 0x00 )
		     	continue;  /* 空エントリのため次のエントリを調査 */

		     /* 0xffはディレクトリエントリの終了を意味する */
		     if ( attr == 0xff ) {
		     	  rc = 3; /* File not found */
		     	  goto out;  /* ファイルが見つからなかった */
		     }

		     /* ファイル名部分をIFBADの内容と比較する
		      * (FCOMPの中で, 両者のバッファポインタをインクリメントしてから
		      * 比較するので, memcmpで記載すると以下に相当する処理となる)
		      */
		    if ( !memcmp(#DTBUF+ (ディレクトリエントリ長(32) * i) + 1,
		       	 #IFBAD + 1, 16) ) {
			 *res_dent = res;  /* 呼び出し元に見つかったエントリを返却 */
		       	 goto out;
		    }
	    }
       }

out:
	return rc;
}
--- 擬似コード


FCBSCH:
	PUSH 	BC		; BCを保存
	LD	C,16		; Cに16(Direntory entryのレコード数(1クラスタ)
	LD	DE,(#DIRPS)	; DIRPSのレコード番号を取得
FCBSC1:
	LD	HL,(#DTBUF)     ; データバッファのアドレスを取得
	LD	A,1             ; セクタ読み込む
	CALL 	DSKRED		; DTBUFにディレクトリエントリを読み込む
	JR	C, FCBSC6	; エラー時はCフラグを保持して抜ける(IOエラー)
	LD	B,8		; 1レコード中のエントリ数(8エントリ)

FCBSC2:				; 1エントリ中から対象ファイルを探す
	LD	A,(HL)		; データバッファから一文字読み込む(ATTR)
	CP	$FF             ; 最終ディレクトリエントリの場合は
	JR	Z,FCBSC4	; サブルーチンから抜ける
	OR      A		; Aが00 (空きエントリ)の場合は
	JR      Z,FCBSC3	; 次のエントリへ
	PUSH	DE		; DIRPSを保存
	LD	DE,(#IFBAD)    	; DEで情報ブロックの内容を指す
	CALL    FCOMP		; FCOMP(27cd)でファイル名を比較する
	POP	DE              ; DIRPSを復元
	JR	Z,FCBSC5        ; ファイル名が一致したら正常終了
FCBSC3:
	PUSH	DE		; DIRPSを保存
	LD	DE,32           ; ディレクトリエントリ長追加(次のエントリへ)
	ADD	HL,DE           ; (HLは次のエントリを指す)
	POP	DE		; DIRPSを復元
	DJNZ	FCBSC2		; 8エントリ(レコード内の全エントリを調査するまで繰り返す
	INC	DE		; 調査対象レコード番号を加算
	DEC	C		; 残り調査エントリ数を減算
	JR	NZ,FCBSC1	; 0でなければディレクトリエントリ調査を継続
FCBSC4:                         ; ディレクトリエントリの終端検出時の処理
	DB	$3E		; 3E AF = LD A,0AFhにしてXOR Aの処理をスキップする
			        ; これにより, A!=0にしてZフラグでのFile not found判定を
				; を行えるようにする(終端まで正常に検索したと言う意味)
FCBSC5:				; 呼び元でCフラグが立っておらず, かつ, Aが0でなければ
				; File not found扱いにするよう処理している
	XOA	A		; Zフラグ, Cフラグをクリア
	OR	A		; Aが0の場合Zフラグを立て, そうで無ければZフラグを落とす
FCBSC6:
	POP	BC
	RET

FCOMP(0x27CD)

HL, DEのそれぞれが指しているアドレスの次のアドレス16バイトを比較する

(* #IFBADとディスクのディレクトリエントリ中のファイル名(16文字)を比較する
ためのFCBSCHの下請けサブルーチンで, 他からは呼ばれない)

入力: DE 比較する文字列(#IFBAD内のファイル名部分の先頭アドレス)
      HL 比較対象ディレクトリエントリデータのファイル名部分の先頭アドレス

破壊レジスタ: AF
保存レジスタ: BC, DE, HL
フラグ:C 比較する文字列(#IFBAD内のファイル名部分の先頭アドレス)の方が小さい
       Z 比較する文字列(#IFBAD内のファイル名部分の先頭アドレス)の方と等しい
       NC: 比較する文字列(#IFBAD内のファイル名部分の先頭アドレス)が
       	   比較対象ディレクトリエントリ以上

FCOMP:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	B, 16	; 比較文字列長
FCOMP1:
	LD	A, (DE)
	CP	(HL)
	JR	NZ, FCOMP2
	DJNZ	FCOMP1
FCOMP2:
	POP	HL
	POP	DE
	POP	BC
	RET
